---
format: gfm
execute:
  daemon: false
---

# Welcome to pycdo

|        |        |
|--------|--------|
| Package | [![Latest PyPI Version](https://img.shields.io/pypi/v/pycdo.svg)](https://pypi.org/project/pycdo/) [![Supported Python Versions](https://img.shields.io/pypi/pyversions/pycdo.svg)](https://pypi.org/project/pycdo/)   |
| Coverage | [![Codecov test coverage](https://codecov.io/gh/eliocamp/pycdo/graph/badge.svg)](https://app.codecov.io/gh/eliocamp/pycdo) | 
| Meta   | [![Code of Conduct](https://img.shields.io/badge/Contributor%20Covenant-v2.0%20adopted-ff69b4.svg)](CODE_OF_CONDUCT.md) |

pycdo is a wrapper for the Climate Data Operators (CDO). 
It allows chaining CDO operators using method chaining and handles options and temporary files for you. 

## Get started

You can install this package into your preferred Python environment using pip:

```bash
pip install pycdo
```

## Example

```{python}
from pycdo import cdo, cdo_options, cdo_cache, geopotential
```


The ymonmean operator computes monthly annual cycle. The pycdo function
is `cdo_ymonmean()`

```{python}
cdo(geopotential).ymonmean()
```

The output just prints the command with a place holder output. Use
`.execute()` to actually run the command. If no output file is
specified, then the result is saved in a tempfile.

```{python}
cdo(geopotential).ymonmean().execute()
```

Operators can be chained. Lets select just the Southern Hemisphere
first.

```{python}
(
    cdo(geopotential)
    .sellonlatbox(0, 360, -90, 0)
    .ymonmean()
    .execute()
)
```

We can save operations to execute later or as input for other operations 

```{python}

sh_geopotential = (
    cdo(geopotential)
    .sellonlatbox(0, 360, -90, 0)
    .sellevel(300)
    .ymonmean()
) 

cdo(sh_geopotential).ymonmean().execute()
```

Temporary files are deleted when the variables holding them are garbage collected to prevent blowing up disk space when iterating over the same code. 

For long-running operations, you can set up a cache. 

```{python}
cdo_cache.set("data/pycdo")
```

This turns off the automatic deletion and returns existing files instead of re-runing CDO operators. 

```{python}
import time
start = time.time()
sh_geopotential.execute()
time.time() - start
```

The second run just returns the existing file, so it's faster. 

```{python}
start = time.time()
sh_geopotential.execute()
time.time() - start
```

```{python}
cdo_cache.forget() # Cleanup cache
```

You can set global options that will apply to all operations. 

```{python}
cdo_options.set("-Z")  # Compress result
sh_geopotential
```


## Prior art

There is [another python wrapper around cdo](https://github.com/Try2Code/cdo-bindings). 

The biggest difference between the cdo and pycdo packages are the delayed execution and chaining syntax. 

For example, this is how chaining works in the cdo package

```python
cdo.seltimestep('1/10', input='-selvar,u10,v10 '+infile, output=outfile)
```

Instead of using the pythonic `selvar("u10", "v10")`, the input switches to the command line syntax `-selvar,u10,v10` passed as a string.
By writing strings instead of cose, the user loses autocomplete, syntax checking and discoverabilty.
It also requires the user to understand and be able to write using two different languages. 
Plus, the order of operations is reversed: we read `seltimestep` first and `selvar` next even through the order of operations is first to select the variable and then to select the timestep. 

The equivalent using pycdo would be this 

```python
(
   cdo("infile")
   .selvar("u10", "v10")
   .seltimestep("1/10")
   .execute(output = outfile)
)
```

Which, is more readable.
Each step is it's own element in a chain and is written in order.
Plus autocomplete prevents typos, saves on keystrokes and helps with discoverability.

On the other hand, the cdo package has an extremely robust logging system.
pycdo doesn't do logging yet. 

pycdo also is not integrated with xarray; it just returns paths to files.
The cdo package, on the other hand, can load data directly as xarray.
This makes pycdo much simpler and with fewer dependencies. 


## Copyright

- Copyright Â© 2025 Elio Campitelli.
- Free software distributed under the [MIT License](./LICENSE).
